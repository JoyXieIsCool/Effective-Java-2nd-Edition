通常更倾向于重用同一个对象而不是创建一个新的、功能相同的对象，重用的方式既快速又流行，如果一个对象是不可变的(immutable，见第15条)，那么它总是可以被重用的。  

作为一个极端的反面例子，思考下面的语句：  

```java
String s = new String("stringette"); // DON'T DO THIS!
```

上述语句在每次执行时都创建一个新的`String`实例，且所有的这些创建都不是必要的。传递给`String`的构造器参数("stringette")本身就是一个`String`的实例，它与构造器创建的所有对象在功能上都是等价的。如果这种使用方式发生在一个循环或频繁调用的方法中，则会不必要地创建成千上万个`String`实例。

下面是一个简单的改进版本：  

```java
String s = "stringette";
```

这个版本使用了一个单一`String`实例，而不是在每次执行时创建一个新对象。而且它保证了运行在同一个虚拟机上面的所有代码都可以重用这个对象，只要它们刚好包含了同样的字符串字面常量[JLS, 3.10.5]。

对于同时提供了静态工厂方法(见第1条)和构造器的不可变类，你通常可以通过优先使用静态工厂方法的方式来避免创建不必要的对象。例如，静态工厂方法`Boolean.valueOf(String)`几乎总是优先于`Boolean(String)`构造器。构造器在每次被调用时都会创建一个新的对象，而静态工厂方法从不要求这么实现，并且在实践中也不会这么做。

除了重用不可变对象以外，你也可以重用那些已知不会被修改的可变对象。下面是一个更微妙且更常见的反面例子，它涉及到可变的`Date`对象，而它们的值一旦被计算好就不会被修改。这个类建立了一个人的模型，并且有一个`isBabyBoomer`方法判断一个人是否是“baby boomer”(婴儿潮时期出生的人)。也即判断此人是否在1946至1964年之间出生：  

```java
public class Person {    private final Date birthDate;
        // Other fields, methods, and constructor omitted
    // DON'T DO THIS!    public boolean isBabyBoomer() {        // Unnecessary allocation of expensive object        Calendar gmtCal =            Calendar.getInstance(TimeZone.getTimeZone("GMT"));        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);        Date boomStart = gmtCal.getTime();        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);        Date boomEnd = gmtCal.getTime();        return birthDate.compareTo(boomStart) >= 0 &&               birthDate.compareTo(boomEnd)   <  0;	}
}	
```

`isBabyBoomer`方法在每次调用时，它都不必要地创建了一个新的`Calendar`，一个`TimeZone`和两个`Date`实例。下面的方法使用静态初始化器避免了这种低效的方式：  

```java
class Person {    private final Date birthDate;    // Other fields, methods, and constructor omitted
        /**     * The starting and ending dates of the baby boom.     */    private static final Date BOOM_START;    private static final Date BOOM_END;    static {        Calendar gmtCal =            Calendar.getInstance(TimeZone.getTimeZone("GMT"));        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);        BOOM_START = gmtCal.getTime();        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);        BOOM_END = gmtCal.getTime();    }
        public boolean isBabyBoomer() {        return birthDate.compareTo(BOOM_START) >= 0 &&               birthDate.compareTo(BOOM_END)   <  0;    }
}
```

改进版的`Person`类只在初始化的时候创建了一次`Calendar`，`TimeZone`和`Date`实例，而不是每次调用`isBabyBoomer`方法时创建它们。如果`isBabyBoomer`方法被频繁调用，那么这种方式可以使性能得到极大提升。在我的机器上，每调用一千万次，原始版本需要32000毫秒，改进版本只需要130毫秒，大约快了250倍。不仅性能得到提升，而且代码也更清晰了。把`boomStart`和`boomEnd`从局部变量改为静态final属性，更加清晰地说明了这些日期应该被当成常量来看待，这使得代码更容易理解。但是从全面的来看待，这种优化并不是总能带来如此巨大的性能提升，因为本例中创建`Calendar`实例的代价特别高。

