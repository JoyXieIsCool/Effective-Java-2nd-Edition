通常更倾向于重用同一个对象而不是创建一个新的、功能相同的对象，重用的方式既快速又流行，如果一个对象是不可变的(immutable，见第15条)，那么它总是可以被重用的。  

作为一个极端的反面例子，思考下面的语句：  

```java
String s = new String("stringette"); // DON'T DO THIS!
```

上述语句在每次执行时都创建一个新的`String`实例，且所有的这些创建都不是必要的。传递给`String`的构造器参数("stringette")本身就是一个`String`的实例，它与构造器创建的所有对象在功能上都是等价的。如果这种使用方式发生在一个循环或频繁调用的方法中，则会不必要地创建成千上万个`String`实例。

下面是一个简单的改进版本：  

```java
String s = "stringette";
```

这个版本使用了一个单一`String`实例，而不是在每次执行时创建一个新对象。而且它保证了运行在同一个虚拟机上面的所有代码都可以重用这个对象，只要它们刚好包含了同样的字符串字面常量[JLS, 3.10.5]。

对于同时提供了静态工厂方法(见第1条)和构造器的不可变类，你通常可以通过优先使用静态工厂方法的方式来避免创建不必要的对象。例如，静态工厂方法`Boolean.valueOf(String)`几乎总是优先于`Boolean(String)`构造器。构造器在每次被调用时都会创建一个新的对象，而静态工厂方法从不要求这么实现，并且在实践中也不会这么做。

除了重用不可变对象以外，你也可以重用那些已知不会被修改的可变对象。下面是一个更微妙且更常见的反面例子，它涉及到可变的`Date`对象，而它们的值一旦被计算好就不会被修改。这个类建立了一个人的模型，并且有一个`isBabyBoomer`方法判断一个人是否是“baby boomer”(婴儿潮时期出生的人)。也即判断此人是否在1946至1964年之间出生：  

```java
public class Person {    private final Date birthDate;
        // Other fields, methods, and constructor omitted
    // DON'T DO THIS!    public boolean isBabyBoomer() {        // Unnecessary allocation of expensive object        Calendar gmtCal =            Calendar.getInstance(TimeZone.getTimeZone("GMT"));        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);        Date boomStart = gmtCal.getTime();        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);        Date boomEnd = gmtCal.getTime();        return birthDate.compareTo(boomStart) >= 0 &&               birthDate.compareTo(boomEnd)   <  0;	}
}	
```

`isBabyBoomer`方法在每次调用时，它都不必要地创建了一个新的`Calendar`，一个`TimeZone`和两个`Date`实例。下面的方法使用静态初始化器避免了这种低效的方式：  

```java
class Person {    private final Date birthDate;    // Other fields, methods, and constructor omitted
        /**     * The starting and ending dates of the baby boom.     */    private static final Date BOOM_START;    private static final Date BOOM_END;    static {        Calendar gmtCal =            Calendar.getInstance(TimeZone.getTimeZone("GMT"));        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);        BOOM_START = gmtCal.getTime();        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);        BOOM_END = gmtCal.getTime();    }
        public boolean isBabyBoomer() {        return birthDate.compareTo(BOOM_START) >= 0 &&               birthDate.compareTo(BOOM_END)   <  0;    }
}
```

改进版的`Person`类只在初始化的时候创建了一次`Calendar`，`TimeZone`和`Date`实例，而不是每次调用`isBabyBoomer`方法时创建它们。如果`isBabyBoomer`方法被频繁调用，那么这种方式可以使性能得到极大提升。在我的机器上，每调用一千万次，原始版本需要32000毫秒，改进版本只需要130毫秒，大约快了250倍。不仅性能得到提升，而且代码也更清晰了。把`boomStart`和`boomEnd`从局部变量改为静态final属性，更加清晰地说明了这些日期应该被当成常量来看待，这使得代码更容易理解。但是从全面的来看待，这种优化并不是总能带来如此巨大的性能提升，因为本例中创建`Calendar`实例的代价特别高。

如果改进版的`Person`类被实例化了，但是它的`isBabyBoomer`方法从未被调用，那么`BOOM_START`和`BOOM_END`属性就成了不必要的创建。可以在`isBabyBoomer`方法第一次被调用时通过懒加载(lazily initializing，见第71条)来消除这些不必要的创建，但是这不推荐。正如懒加载的常见情况一样，它使得实现变复杂了，并且不太可能在我们已完成的工作上产生可见的性能提升(见第55条)。

在本条目前面的例子中，很明显有问题的对象可以被重用，因为它们在初始化后不再被修改。但也有一些不那么明显的情况，考虑一下适配器(adapters)[Gamma95,p. 139]的例子，它们也被称为视图(views)。一个适配器是这样一个对象：它把服务委托给一个支持对象(backing object)，并且为支持对象提供一个替代的接口。因为适配器在它的支持对象之上是没有状态的，所以对于一个给定的对象，没有必要为它创建多个适配器实例。



