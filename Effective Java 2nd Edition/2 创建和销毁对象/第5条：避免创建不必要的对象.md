通常更倾向于重用同一个对象而不是创建一个新的、功能相同的对象，重用的方式既快速又流行，如果一个对象是不可变的(immutable，见第15条)，那么它总是可以被重用的。  

作为一个极端的反面例子，思考下面的语句：  

```java
String s = new String("stringette"); // DON'T DO THIS!
```

上述语句在每次执行时都创建一个新的`String`实例，且所有的这些创建都不是必要的。传递给`String`的构造器参数("stringette")本身就是一个`String`的实例，它与构造器创建的所有对象在功能上都是等价的。如果这种使用方式发生在一个循环或频繁调用的方法中，则会不必要地创建成千上万个`String`实例。

下面是一个简单的改进版本：  

```java
String s = "stringette";
```

这个版本使用了一个单一`String`实例，而不是在每次执行时创建一个新对象。而且它保证了运行在同一个虚拟机上面的所有代码都可以重用这个对象，只要它们刚好包含了同样的字符串字面常量[JLS, 3.10.5]。

对于同时提供了静态工厂方法(见第1条)和构造器的不可变类，你通常可以通过优先使用静态工厂方法的方式来避免创建不必要的对象。例如，静态工厂方法`Boolean.valueOf(String)`几乎总是优先于`Boolean(String)`构造器。构造器在每次被调用时都会创建一个新的对象，而静态工厂方法从不要求这么实现，并且在实践中也不会这么做。

除了重用不可变对象以外，你也可以重用那些已知不会被修改的可变对象。下面是一个更微妙且更常见的反面例子，它涉及到可变的`Date`对象，而它们的值一旦被计算好就不会被修改。这个类建立了一个人的模型，并且有一个`isBabyBoomer`方法判断一个人是否是“baby boomer”(婴儿潮时期出生的人)。也即判断此人是否在1946至1964年之间出生：  

```java
public class Person {    private final Date birthDate;
        // Other fields, methods, and constructor omitted
    // DON'T DO THIS!    public boolean isBabyBoomer() {        // Unnecessary allocation of expensive object        Calendar gmtCal =            Calendar.getInstance(TimeZone.getTimeZone("GMT"));        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);        Date boomStart = gmtCal.getTime();        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);        Date boomEnd = gmtCal.getTime();        return birthDate.compareTo(boomStart) >= 0 &&               birthDate.compareTo(boomEnd)   <  0;	}
}	
```

`isBabyBoomer`方法在每次调用时，它都不必要地创建了一个新的`Calendar`，一个`TimeZone`和两个`Date`实例。下面的方法使用静态初始化器避免了这种低效的方式：  

```java
class Person {    private final Date birthDate;    // Other fields, methods, and constructor omitted
        /**     * The starting and ending dates of the baby boom.     */    private static final Date BOOM_START;    private static final Date BOOM_END;    static {        Calendar gmtCal =            Calendar.getInstance(TimeZone.getTimeZone("GMT"));        gmtCal.set(1946, Calendar.JANUARY, 1, 0, 0, 0);        BOOM_START = gmtCal.getTime();        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);        BOOM_END = gmtCal.getTime();    }
        public boolean isBabyBoomer() {        return birthDate.compareTo(BOOM_START) >= 0 &&               birthDate.compareTo(BOOM_END)   <  0;    }
}
```


