通常一个类要允许客户端获取它的实例的方式就是提供一个构造函数，不过还有一个方法，它应该成为每个程序员的工具箱的一部分。一个类可以提供一个共有的静态工厂方法，即一个简单的可以返回该类对象的静态方法。下面是一个简单的例子，摘自`Boolean`（基本类型boolean装箱后的原始类型）。这个方法把一个`boolean`原始类型转为了`Boolean`对象引用：  

```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

需要注意的是，一个静态工厂方法跟设计模式[Gamma95, p. 107]中的工厂方法模式是不一样的。本条目中描述的静态工厂方法跟设计模式中的并不直接相等。

一个类可以给它的客户提供静态工厂方法而不是构造器，或者说不仅仅是构造器。提供静态工厂方法而不是公有构造器即有优点也有缺点。

**静态工厂方法的第一个优点是，不像构造器，它是有名字的**。如果构造期的参数本身没有很好地描述正被返回的对象，那么一个命名良好的静态工厂方法会更容易使用且产生的客户代码也会更容易阅读。例如`BigInteger(int, int, Random)`这个构造器，它可能返回素数，更好的表达方法是一个名为`BigInteger.probablePrime`的静态工厂方法。(这个方法最终在1.4发行版中加上了。)

给定了签名的情况下，一个类只有一个对应的构造器。程序员通常知道如何绕开这个限制：通过提供两个构造期，它们的参数列表仅仅是参数类型顺序不同。这其实是一个不好的做法，这样的API的用户通常不记得哪个是哪个，并且最后可能会调用了错的那个构造器。当其他人阅读调用了这些构造器的代码时并不知道这些代码做了什么，除非参考类的说明文档。

因为静态工厂方法有名字，所以它们并不会受到上一段中讨论的限制。如果一个类看上去需要同样签名的多个构造器，那么就用静态工厂方法取代这些构造器，并且仔细地挑选名字来强调它们的不同。

**静态工厂方法的第二个优点是，不像构造器，它们并不要求每次调用都创建一个对象**。这允许不可变类(immutable classes，见第15条)使用预先构造好的实例，或者创建好之后缓存这些实例，在之后重复分发它们以避免创造不必要的重复对象。`Boolean.valueOf(boolean)`方法说明了这项技术：它从不创建一个对象。这种方法类似于`Flyweight`模式[Gamma95, p. 195]，当频繁地请求相等的对象时它可以巨大地提升性能，特别是当创建它们的代价比较昂贵时。

静态工厂方法在重复调用时返回同一个对象的能力允许类对何时存在什么对象维持着严格的控制。这样做的类被称为实例受控的(instance-controlled)。编写实例受控的类有几个原因，实例受控允许一个类保证它是单例(见条目3)的或者是不可实例化(见条目4)的，而且它允许一个不可变类(见条目15)保证没有两个相同的实例存在：即当且仅当 `a==b`时`a.equals(b)`才为true。如果一个类做出了这种保证，那么它的客户可以使用==运算符而不是`equals(Object)`方法，这样也许可以提升性能。枚举(Enum)类型(见第30条)就提供了这种保证。

**静态工厂方法的第三个优点是，不像构造器，它们可以返回任何返回类型的子类型**。当你要选择返回对象的类型时，这可以给你巨大的灵活性。


