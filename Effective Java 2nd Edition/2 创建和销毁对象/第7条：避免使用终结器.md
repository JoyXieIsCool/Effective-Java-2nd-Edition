
**终结器是无法预测的，通常很危险且没有必要使用**。使用它们可能会造成行为不稳定、极差的性能和潜在的问题。当然终结器方法也有可用之处，我们会在本条目稍后介绍它们，但是根据经验，你应当避免使用终结器。

C++程序员需要注意这个警告：不要把Java的终结器等同于C++中的析构器(destructors)。在C++中，析构器是回收与对象相关的资源的常规方式，是构造器所必需的对应物。在Java中，当对象变为不可达时，垃圾回收器会回收与之相关的存储空间，并不需要程序员做额外的工作。C++析构器也被用于回收其它非内存资源，在Java中，通常用`try-finally`块来完成类似的工作。

终结器的一个缺点是无法保证它们会被准时地执行[JLS, 12.6]。在对象变得不可达之后，一直到终结器被执行，这个时间跨度可能是任意长的。这意味着你**绝不应该在终结器中做任何对时间敏感的操作**。例如，依赖终结器来关闭文件是一个严重的错误，因为已经打开的文件描述符是有限的资源，如果由于JVM延迟执行了终结器，则会有许多文件保持打开状态，一个程序可能会因为无法再打开新文件而出错。

及时地执行终结器是垃圾回收算法的一个主要功能，这种算法在不同的JVM实现中也是不同的。依赖终结器及时执行的程序的行为也同样会随着JVM实现的不同而变得不同，一个程序完全有可能在你进行测试的JVM上运行良好，但是在你最重要的客户所喜欢的JVM上运行失败。

延迟终结器的执行不只是一个理论问题，为一个类提供终结器在很罕见的情况下可能会随意延迟它的实例回收。有一个长期运行的界面程序会意外地抛出`OutOfMemoryError`错误而终止运行，一个同事在调试时分析发现，程序终止时有数千个图形对象正在它的终结器队列里等待被终结和回收。不幸的是，终结器线程的运行优先级比其他应用线程低，因此图形对象被终结的速度跟不上进入队列的速度。Java语言的规范并没有保证哪个线程会执行终结器，所以除了不使用终结器之外，没有一种可移植的方式来阻止这种问题。

Java语言规范不仅不保证终结器会被及时执行，它也不保证终结器会被执行。这是很有可能的，甚至有可能一个程序在终结的时候没有执行不可达对象的终结器方法。结论就是：**你绝不应该依赖终结器来更新重要的持久化状态**。例如，依赖终结器来释放共享资源(例如数据库)上的持久化锁很容易让你的整个分布式系统垮掉。

不要被`System.gc`和`System.runFinalization`方法迷惑，它们也许可以增加终结器执行的概率，但是并不保证会执行。唯一声明了可以保证终结器被执行的是`System.runFinalizersOnExit`方法，以及它臭名昭著的孪生兄弟`Runtime.runFinalizersOnExit`方法，它们都有致命的缺陷并且已经被废弃了[ThreadStop]。

如果说你还不相信要避免使用终结器的话，这里还有一种值得思考的情形：如果在终结器执行期间抛出了一个未捕获的异常，那么异常会被忽略，那个对象的终结器过程也会终止执行[JLS,12.6]。未捕获的异常会让对象处于损坏状态，如果有另外一个线程企图使用这样的损坏对象，那么任何不确定的行为都有可能发生。通常一个未捕获的异常会终止线程并打印栈轨迹，但如果发生在终结器中，那么它不会打印栈轨迹，甚至连警告也不会打印。

