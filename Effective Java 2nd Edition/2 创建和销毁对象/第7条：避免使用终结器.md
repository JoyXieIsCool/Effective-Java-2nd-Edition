
**终结器是无法预测的，通常很危险且没有必要使用**。使用它们可能会造成行为不稳定、极差的性能和潜在的问题。当然终结器方法也有可用之处，我们会在本条目稍后介绍它们，但是根据经验，你应当避免使用终结器。

C++程序员需要注意这个警告：不要把Java的终结器等同于C++中的析构器(destructors)。在C++中，析构器是回收与对象相关的资源的常规方式，是构造器所必需的对应物。在Java中，当对象变为不可达时，垃圾回收器会回收与之相关的存储空间，并不需要程序员做额外的工作。C++析构器也被用于回收其它非内存资源，在Java中，通常用`try-finally`块来完成类似的工作。

终结器的一个缺点是无法保证它们会被准时地执行[JLS, 12.6]。在对象变得不可达之后，一直到终结器被执行，这个时间跨度可能是任意长的。这意味着你**绝不应该在终结器中做任何对时间敏感的操作**。例如，依赖终结器来关闭文件是一个严重的错误，因为已经打开的文件描述符是有限的资源，如果由于JVM延迟执行了终结器，则会有许多文件保持打开状态，一个程序可能会因为无法再打开新文件而出错。

及时地执行终结器是垃圾回收算法的一个主要功能，这种算法在不同的JVM实现中也是不同的。依赖终结器及时执行的程序的行为也同样会随着JVM实现的不同而变得不同，一个程序完全有可能在你进行测试的JVM上运行良好，但是在你最重要的客户所喜欢的JVM上运行失败。

延迟终结器的执行不只是一个理论问题，为一个类提供终结器在很罕见的情况下可能会随意延迟它的实例回收。有一个长期运行的界面程序会意外地抛出`OutOfMemoryError`错误而终止运行，一个同事在调试时分析发现，程序终止时有数千个图形对象正在它的终结器队列里等待被终结和回收。不幸的是，终结器线程的运行优先级比其他应用线程低，因此图形对象被终结的速度跟不上进入队列的速度。Java语言的规范并没有保证哪个线程会执行终结器，所以除了不使用终结器之外，没有一种可移植的方式来阻止这种问题。

Java语言规范不仅不保证终结器会被及时执行，它也不保证终结器会被执行。这是很有可能的，甚至有可能一个程序在终结的时候没有执行不可达对象的终结器方法。结论就是：**你绝不应该依赖终结器来更新重要的持久化状态**。例如，依赖终结器来释放共享资源(例如数据库)上的持久化锁很容易让你的整个分布式系统垮掉。

不要被`System.gc`和`System.runFinalization`方法迷惑，它们也许可以增加终结器执行的概率，但是并不保证会执行。唯一声明了可以保证终结器被执行的是`System.runFinalizersOnExit`方法，以及它臭名昭著的孪生兄弟`Runtime.runFinalizersOnExit`方法，它们都有致命的缺陷并且已经被废弃了[ThreadStop]。

如果说你还不相信要避免使用终结器的话，这里还有一种值得思考的情形：如果在终结器执行期间抛出了一个未捕获的异常，那么异常会被忽略，那个对象的终结器过程也会终止执行[JLS,12.6]。未捕获的异常会让对象处于损坏状态，如果有另外一个线程企图使用这样的损坏对象，那么任何不确定的行为都有可能发生。通常一个未捕获的异常会终止线程并打印栈轨迹，但如果发生在终结器中，那么它不会打印栈轨迹，甚至连警告也不会打印。

还有一点：**使用终结器有严重的性能问题。**在我的机器上，创建和销毁一个简单对象大约花费5.6纳秒，添加了终结器后，时间增加到了2400纳秒。换而言之，使用终结器大约使得创建和销毁对象慢了430倍。

那么对于那些封装了资源(例如文件或线程)并且要求回收的对象，除了使用终结器以外，你还能如何做呢？**你只需要提供一个显式的终结方法，**然后强制类的客户对每一个不再需要的实例都调用该方法。还有个值得一提的细节，实例必须跟踪它是否被终结：显式的终结方法必须记录一个私有属性用于标识该对象已经不再有效，类的其他方法必须检查这个属性，如果这些方法在对象已被终结后调用需要抛出一个`IllegalStateException`异常。

显式终结方法的一个典型例子是定义在`InputStream`，`OutputStream`和`java.sql.Connection`中的`close`方法。另一个例子是定义在`java.util.Timer`中的`cancel`方法，它执行必要的状态转换使得与一个`Timer`实例关联的线程可以优雅地终结它自己。还有`java.awt`中的`Graphics.dispose`和`Window.dispose`方法，它们通常因为低性能而被忽略。一个相关的方法是`Image.flush`，它会回收与一个`Image`实例关联的所有资源，但任然保持对象为可用状态，如果必要的话还会重新分配资源。

**显式终结方法通常跟`try-finally`块组合使用以保证终止行为`**。在finally语句块中调用显式终结方法可以保证它会被执行，即使对象在使用过程中抛出了异常：  

```java
// try-finally block guarantees execution of termination methodFoo foo = new Foo(...);try {    // Do what must be done with foo    ...} finally {    foo.terminate();  // 显式终结方法}
```

那么终结器有没有任何好处呢？它们有两种合法的用途：第一种用途是当对象持有者忘记调用显式终结方法时，它可以充当“安全网”的角色。虽然终结器不能保证被及时地执行，但是延迟释放资源总要好过永远不释放，尤其是在客户无法调用显式终结方法的情况下(但愿不要发生)。**如果终结器发现资源没有被终止，它需要记录一条警告信息**，因为这反映了客户代码的中的一个bug并应该得到修复。如果你正考虑编写这样一个“安全网”的终结器，请认真考虑清楚是否值得付出额外的代价来做出这种额外的保证。

上文的显式终结方法模式引用例子中的四个类(`FileInputStream`, `FileOutputStream`, `Timer`和 `Connection`)也拥有充当安全网的终结器，用以防止它们的显式终结方法未被调用。遗憾的是，这些终结器没有记录警告，并且这些警告通常在API发行之后也无法被添加，因为它明显会打破已有的客户代码。


